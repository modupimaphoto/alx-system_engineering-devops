# 0x04. Loops, conditions and parsing

## General

- How to create SSH keys
- What is the advantage of using #!/usr/bin/env bash over #!/bin/bash
- How to use while, until and for loops
- How to use if, else, elif and case condition statements
- How to use the cut command
- What are files and other comparison operators, and how to use them

### 1. Creating SSH Keys:

To create SSH keys, you can use the `ssh-keygen` command. Here's a simple guide:

```bash
# Open a terminal
ssh-keygen -t rsa -b 4096 -C "your_email@example.com"
```

This command generates a new SSH key using the provided email as a label. You can choose a different file name, or just press Enter to use the default (`id_rsa`). The key files will be stored in the `~/.ssh/` directory.

### How do I set up SSH authentication keys?

Run the following command to create an SSH key pair. You can leave the passphrase blank if you do not wish to "unlock" your key each time you use it:

```bash
ssh-keygen -t rsa
```

The output will be similar to this

```
Generating public/private rsa key pair.
Enter file in which to save the key (/home/a/.ssh/id_rsa): 
Created directory '/home/a/.ssh'.
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /home/a/.ssh/id_rsa.
Your public key has been saved in /home/a/.ssh/id_rsa.pub.
The key fingerprint is:
3e:4f:05:79:3a:9f:96:7c:3b:ad:e9:58:37:bc:37:e4 a@A
```

Then you'll need to copy the new key to your server.

After copying the SSH keys you can log into your machine without a password.

### 2. `#!/usr/bin/env bash` vs `#!/bin/bash`:

The shebang (`#!/bin/bash`) at the beginning of a script tells the system which interpreter to use. Using `#!/usr/bin/env bash` is more flexible because it locates the Bash interpreter in the system's PATH. This can be useful if the Bash interpreter is not in the default location.

### 3. Loops (while, until, for):

- **While Loop:**
  ```bash
  while [ condition ]; do
      # commands
  done
  ```

- **Until Loop:**
  ```bash
  until [ condition ]; do
      # commands
  done
  ```

- **For Loop:**
  ```bash
  for variable in list; do
      # commands
  done
  ```
  
  ```bash
  for NAME [in LIST ]; do COMMANDS; done
  ```
  
	If [in LIST] is not present, it is replaced with in $@ and for executes the COMMANDS once for each positional parameter that is set.

	The return status is the exit status of the last command that executes. 
	If no commands are executed because LIST does not expand to any items, the return status is zero.

	NAME can be any variable name, although i is used very often. LIST can be any list of words, strings or numbers, 
	which can be literal or generated by any command. The COMMANDS to execute can also be any operating system commands, 
	script, program or shell statement. The first time through the loop, NAME is set to the first item in LIST. 
	The second time, its value is set to the second item in the list, and so on. 
	The loop terminates when NAME has taken on each of the values from LIST and no items are left in LIST.

### 4. Conditional Statements (if, else, elif, case):

- **If-else:**
  ```bash
  if [ condition ]; then
      # commands
  else
      # commands
  fi
  ```

- **Elif (else if):**
  ```bash
  if [ condition ]; then
      # commands
  elif [ another_condition ]; then
      # commands
  else
      # commands
  fi
  ```

- **Case:**
  ```bash
  case "$variable" in
      pattern1)
          # commands
          ;;
      pattern2)
          # commands
          ;;
      *)
          # default commands
          ;;
  esac
  ```

### 5. Cut Command:

The `cut` command is used to extract sections from each line of a file or input. Example:

```bash
# Display the first and second fields of each line in a file
cut -d',' -f1,2 filename.csv
```

### 6. File and Comparison Operators:

- **File Operators:**
  - `-e file`: True if the file exists.
  - `-f file`: True if the file exists and is a regular file.
  - `-d file`: True if the file exists and is a directory.
  
### Returns true if

- `-a`: file exists, This is identical in effect to -e. It has been "deprecated," [1] and its use is discouraged.
- `-f`: file is a regular file (not a directory or device file)
- `-s`: file is not zero size
- `-d`: file is a directory
- `-b`: file is a block device
- `-c`: file is a character device
- `-p`: file is a pipe
- `-h`: file is a symbolic link
- `-L`: file is a symbolic link
- `-S`: file is a socket
- `-t`: file (descriptor) is associated with a terminal device, This test option may be used to check whether the stdin [ -t 0 ] or stdout [ -t 1 ] in a given script is a terminal.
- `-r`: file has read permission (for the user running the test)
- `-w`: file has write permission (for the user running the test)
- `-x`: file has execute permission (for the user running the test)

- `-g`: set-group-id (sgid) flag set on file or directory
If a directory has the sgid flag set, then a file created within that directory belongs to the group that owns the directory, 
not necessarily to the group of the user who created the file. This may be useful for a directory shared by a workgroup.

- `-u`: set-user-id (suid) flag set on file
A binary owned by root with set-user-id flag set runs with root privileges, even when an ordinary user invokes it. 
This is useful for executables (such as pppd and cdrecord) that need to access system hardware. 
Lacking the suid flag, these binaries could not be invoked by a non-root user.

A file with the suid flag set shows an s in its permissions.

- `-k`: sticky bit set

Commonly known as the sticky bit, the save-text-mode flag is a special type of file permission. 
If a file has this flag set, that file will be kept in cache memory, for quicker access.
If set on a directory, it restricts write permission. Setting the sticky bit adds a t to the permissions on the file or directory listing. 
This restricts altering or deleting specific files in that directory to the owner of those files.

If a user does not own a directory that has the sticky bit set, but has write permission in that directory, she can only delete those files that she owns in it. This keeps users from inadvertently overwriting or deleting each other's files in a publicly accessible directory, such as /tmp. (The owner of the directory or root can, of course, delete or rename files there.)

- `-O`: you are owner of file
- `-G`: group-id of file same as yours
- `-N`: file modified since it was last read
- `f1 -nt f2`: file f1 is newer than f2
- `f1 -ot f2`: file f1 is older than f2
- `f1 -ef f2`: files f1 and f2 are hard links to the same file
- `!`: "not" -- reverses the sense of the tests above (returns true if condition absent).

```bash
device0="/dev/sda2"    # /   (root directory)
if [ -b "$device0" ]
then
  echo "$device0 is a block device."
fi

# /dev/sda2 is a block device.



device1="/dev/ttyS1"   # PCMCIA modem card.
if [ -c "$device1" ]
then
  echo "$device1 is a character device."
fi

# /dev/ttyS1 is a character device.
```

- **Comparison Operators (for numeric values):**
  - `-eq`: Equal to
  - `-ne`: Not equal to
  - `-lt`: Less than
  - `-le`: Less than or equal to
  - `-gt`: Greater than
  - `-ge`: Greater than or equal to
  
1. `-eq`: is equal to: `if [ "$a" -eq "$b" ]`
2. `-ne`: is not equal to: `if [ "$a" -ne "$b" ]`
3 `-gt`: is greater than: if `[ "$a" -gt "$b" ]`
4. `-ge`: is greater than or equal to: `if [ "$a" -ge "$b" ]`
5. `-lt`: is less than: `if [ "$a" -lt "$b" ]`
6. `-le`: is less than or equal to `if [ "$a" -le "$b" ]`


1. is less than (within double parentheses): `(("$a" < "$b"))`
2. is less than or equal to (within double parentheses): `(("$a" <= "$b"))`
3. is greater than (within double parentheses): `(("$a" > "$b"))`
4. is greater than or equal to (within double parentheses): `(("$a" >= "$b"))`

1. is less than, in ASCII alphabetical order
```
if [[ "$a" < "$b" ]]

if [ "$a" \< "$b" ]
```

2. is greater than, in ASCII alphabetical order
```
if [[ "$a" > "$b" ]]

if [ "$a" \> "$b" ]
```

1. `-z`: string is null, that is, has zero length
```
String=''   # Zero-length ("null") string variable.

if [ -z "$String" ]
then
  echo "\$String is null."
else
  echo "\$String is NOT null."
fi     # $String is null.
```
2. `-n`: string is not null.

- **String Comparison:**
  - `=`: Equal to
  - `!=`: Not equal to

Example:
```bash
if [ "$a" -eq "$b" ]; then
    # commands
fi
```

These are basic constructs; you can combine them to create more complex scripts and commands. 
Always refer to the respective manual pages (`man`) for detailed information on each command and operator.

### Do not confuse the "=" assignment operator with the = test operator.

####   =  as a test operator

```bash
if [ "$string1" = "$string2" ]
then
   command
fi

#  if [ "X$string1" = "X$string2" ] is safer,
#+ to prevent an error message should one of the variables be empty.
#  (The prepended "X" characters cancel out.)
```


## Shellcheck

Shellcheck is a tool that will help you write proper Bash scripts. 
It will make recommendations on your syntax and semantics and provide advice on edge cases that you might not have thought about.

ShellCheck is a tool that provides static analysis and linting for shell scripts. It helps identify and highlight issues, errors, and potential pitfalls in your shell scripts. ShellCheck analyzes your script's syntax, style, and common mistakes, providing suggestions for improvements.

Key features of ShellCheck include:

1. **Syntax Checking:** Identifies syntax errors and common mistakes in shell scripts.
2. **Style Checking:** Recommends improvements for better coding style and practices.
3. **Variable and Quoting Issues:** Helps catch issues related to variable usage and quoting.
4. **Security Warnings:** Alerts you to potential security vulnerabilities in your scripts.
5. **Compatibility Checks:** Flags issues that may cause problems on different shell implementations.

To use ShellCheck, you can either install it locally on your machine or use it online through the web interface. To install ShellCheck, you can use package managers like `apt`, `yum`, `brew`, or download binaries from the official website.

Here's an example of how you can use ShellCheck:

```bash
# Install ShellCheck on Linux (using apt)
sudo apt-get install shellcheck

# Run ShellCheck on a script
shellcheck your_script.sh
```

ShellCheck is a valuable tool for improving the quality of your shell scripts and ensuring they follow best practices. It's widely used by developers and system administrators to enhance the reliability and maintainability of shell scripts.

